-- Welcome to Leksah.  This is a quick sample package for you to
-- try things out with.  We hope it will be useful for those new
-- to Haskell or just new to Leksah.

-- If you are new to haskell then here are some great sites to visit
-- http://learnyouahaskell.com/
-- http://tryhaskell.org/
-- http://book.realworldhaskell.org/

-- To build this package use
--   * Just make a change while background build is activated
--   * Ctrl+B (OS X Command+B)
--   * Package -> Build

-- When you are ready to create your own workspace and package.
--   * Package -> New

-- Next we are importing some things from other modules.
-- Leksah can normally add these imports for you, just
-- press Ctrl+R (OS X Command+R)

import Data.Monoid ((<>))

-- This strange looking comment adds code only needed when running the
-- doctest tests embedded in the comments
-- $setup
-- >>> import Data.List (stripPrefix)

-- | Simple function to create a hello message.
--
-- The following tells doctest & QuickCheck that if you strip "Hello "
-- from the start of `hello s` you will be left with `s` (for any `s`).
-- QuickCheck will create the test data needed to run this test.
--
-- To automatically run the tests when the package is built, click on
-- the green tick on the tool leksah tool bar.
--
-- To see how this is configured take a look in leksah-welecome.cabal
-- (you can open it with Package -> Edit).
--
-- The code that runs the tests is in the file test/Main.hs.
--
-- prop> stripPrefix "Hello " (hello s) == Just s
hello :: String -> String
hello s = "Hello " <> s

-- | Executable Entry Point
--
-- Here is the entry point for the leksah-welcome executable
--
-- To run it
--   * Select Leksah menu item Package -> Run (or the cogs on the toolbar)
--   * Select "exeMain" and press Ctrl+Enter to run them in ghci
--   * Run "leksah-wellcome" from the command line
-- what the hell is this doing
main :: IO ()
main = putStrLn (hello "World")


-- The above was auto generated by Leksah, I don't really know what any of it means
-- The following are my own notes
-- I'm still kind of confused as to how the build system works
-- from leksah, you do File->Open-Package and find the cabal file, but this doesn' open any source code fileTypefileType
-- you just have to open files seperately if you want to edit the content

-- define some variables
-- this isn't really a variable, you are just aliasing the value of hello 1 with string1
string1 = "hello 1"
string2 = "world 1"
--concat strings
greeting = string1 ++ " " ++ string2

-- calling functions
--dont need parenthesis or commas
--uh why is this not working
-- this will only work in the GHCI
--max 5 7

--if you are sending expressions into functions then you need parenthesis, but again no commas
--uh why is this not working - this will only work in the GHCI
--max (5+2) (sqrt 17)

-- define your own function
-- function name then arguments with no parenthesis or commas, there is no return keyword
square x = x * x

--use other functions in your function
multMax a b x = (max a b) * x

--if statements
-- don't need parenthesis, there must always be an else
posOrNeg x =
    if x >= 0
    then "Positive"
    else "Negative"


--do recursion
--there are no loops in haskel so you have to do recursion
--to the power of
pow2 n =
    if n == 0
    then 1
    else 2 * (pow2 (n-1))

-- mimic a for loop from other languages like C#
--notice the function aliasing, you are using the signature of another function to make a new function that only has 1 argument
-- the other arguments are hard coded to 1 and 0
loopedpow2 n = pow2loop n 1 0
pow2loop n x i =
    if i < n
    then pow2loop n (x*2) (i+1)
    else x


--- LISTS
x = [1,2,3]
empyt = []
-- take an existing list and create a new list with something added to the front
-- the colon is the cons keyword "construct"
--y now has a new list with 0 at the front
y = 0 : x

--con a list
--construct a list starting from an empty list and adding things into it
mylist = 1 : 2 : 3 : 4 : 5 : []


--create a new list from lists
combinedlist = [1,3,4,5] ++ [5,6,7,8]

thefirstthinginthelist = head combinedlist

everythinginthelistexceptthefirstthing = tail combinedlist


--this is a common way to work with lists since you cannot do loops
-- you do recursion sending in the tail of the list and then check for an empty list
--function that will take a list of numbers and return a list of all the numbers doubled
doublenumbers nums=
    if null nums -- this is how you check for null
    then [] -- returning and empty array
    -- this  is taking the first number and multiplying it by 2
    -- then it is combining it with the result of calling the function again sending in the tail
    else (2 * (head nums)) : (doublenumbers (tail nums))



--tuple, this is like object vs array
--lists can only have one type in them
--tuples can have any type in them
--just like in c# you only use these things in very simple cases
myfirsttuple = (1,"hello")


--Pattern matching
--this is pretty consusing because there is no equivelant in c#

--the parenthesis are consfusing, but they are not wrapping the arguments
--the parenthesis represent a tuple, because that is how you define tuples
--so this is a function that takes a tuple of any type a,b and just returns a, which is the first thing in it
myFirst (a,b) = a

--take a tuple and return the second thing in it b
mySecond (a,b) = b







--constructor is just like contructor overload except instead of differen method signatures,you give differnet names
